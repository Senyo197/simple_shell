#include  "shell.h"

/**
  * execute_command - function that exe a command
  *@command: command to be entered
  *@argv: array of commands to be entered
  *Return: always 0
  */
int execute_command_line(char *command, char *argv[])
{
	int status;

	pid_t child_pid = fork();  /* Create a child process */

	if (child_pid == 0)
	{                /* Child process */
		if (execve(command, argv, environ) == -1)
		{       /* Execute the command */
			perror("execve error");
			_exit(1);  /* Exit the child process */
		}
	}
	else if (child_pid > 0)
	{  /* Parent process */
		if (waitpid(child_pid, &status, 0) == -1)
		{  /* Wait for child process */
			perror("waitpid error");  /* Print error if waitpid fails */
		}
	}
	else
	{
		perror("Fork error");  /* Print error if fork fails */
	}

	return (0);
}


int search_execute(char *command, char *argv[])
{
	char full_path[MAX_COMMAND_LENGTH];
	char *path_env = getenv("PATH"), *path;
	if (path_env == NULL)
	{
		fprintf(stderr, "Path variable not set\n");
		return (1);
	}

	path = strtok(path_env, ":");
	while (path != NULL)
	{
		snprintf(full_path, sizeof(full_path), "%s/%s", path, command);

		if (access(full_path, X_OK) == 0)
		{
			execute_command_line(full_path, argv);
			return (0);
		}

		path = strtok(NULL, ":");
	}

	return (1);
}


int execute_command(char *command, char *argv[])
{
	if (strchr(command, '/') != NULL)
	{
		execute_command_line(command, argv);
	}
	else
	{
		if (search_execute(command, argv) != 0)
		{
			fprintf(stderr, "%s: No such file or directory\n", command);
			return (1);
		}
	}

	return (0);
}

/**
  *parse_arguments - function that parse a command string into
  *                  arguments
  *
  *@command: the command to be parsed
  *@args: an array of store the parsed arguments
  *Return: always 0
  */

int parse_arguments(char *command, char *args[])
{
	char *token, quote_char, *end_token;
	int arg_count;

	arg_count = 0;
	token = strtok(command, " ");

	while (token != NULL && arg_count < MAX_ARGUMENTS - 1)
	{
		if (token[0] == '"' || token[0] == '\'')
		{
			quote_char = token[0];
			end_token = token = strtok(NULL, quote_char == '"' ? "\"" : "'");
			if (end_token == NULL)
			{
				fprintf(stderr, "Unmatched %c\n", quote_char);
				free_arguments(args, arg_count);
				return (-1);
			}
			args[arg_count++] = allocate_and_copy(token);
			args[arg_count++] = allocate_and_copy(end_token);
		}
		else
		{
			remove_newline(token);
			args[arg_count++] = allocate_and_copy(token);
		}
		token = strtok(NULL, " ");

	}

	args[arg_count] = NULL;

	return (arg_count);
}
